//-----------------------------------------------------------------------------
// 
//   aes_ian.c - AES implementation
//
//   Author:
//      Ian Rooze - 08/12/2015
//
//   Updates:
//
//-----------------------------------------------------------------------------

#include "types.h"
#include "utils.h"

uint8 key_table[16*15]; // (240 bytes) Each key_table consists of 16 bytes. # of key_table entries depends on keysize. aes-256 is 15 entries

const uint8 sbox[256] = {
0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16 };

const uint8 isbox[256] = {
0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,
0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,
0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,
0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,
0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,
0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,
0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,
0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,
0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,
0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,
0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,
0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,
0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,
0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,
0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,
0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D };

uint8 xtime(uint8 x)
{
	if(x & 0x80) {
		return((x << 1) ^ 0x1b);
	} else {
		return(x << 1);	
	}
}

void aes_set_key(uint8 *key, int keysize)
{
	int ll, mm, num;
	uint8 tcol[4];
	uint8 rconst;

	// Each key_table consists of 16 bytes. # of key_tables depends on keysize
	// For Keysize 128, 1 roundkey generated per loop (11 keys generated)
	// For Keysize 192, 1.5 roundkeys generated per loop (13 keys generated)
	// For keysize 256, 2 roundkeys generated per 2 loop (15 keys generated)

	// compute the next keys
	int lps, step;
	if (keysize==256) {
		lps = 7;
	} else if (keysize==192) {
		lps = 8;
	} else {
		lps = 10;
	}
	step = keysize>>3;
	for (ll=0; ll<step; ll=ll+1) {
		key_table[ll] = key[ll];
	}
	
	num = step;
	for (mm=0; mm<lps; mm=mm+1) {
		// compute rconst
		if (mm==0) {
			rconst = 1;
		} else {
			rconst = xtime(rconst);
		}
		// sbox /column shifting/ xor rconst
		tcol[0] = sbox[key_table[num -3]] ^ rconst;
		tcol[1] = sbox[key_table[num -2]];
		tcol[2] = sbox[key_table[num -1]];
		tcol[3] = sbox[key_table[num -4]];
		// XOR columns with existing key
		for (ll=0; ll<step; ll=ll+1) {
			if (ll==16 && step==32) {
				tcol[0] = sbox[key_table[num -4]];
				tcol[1] = sbox[key_table[num -3]];
				tcol[2] = sbox[key_table[num -2]];
				tcol[3] = sbox[key_table[num -1]];
			}
			key_table[num] = key_table[num-step] ^ tcol[ll&0x3];
			tcol[ll&0x3] = key_table[num];
			num++;
			if (num>=(15*16)) {
				ll = step;	// we are done
			}
		}
	}
}

void aes_subBytes(uint8 *buf)
{
    int i;

	i = 16;		
	while (i--) {
		buf[i] = sbox[buf[i]];
	}
}

void aes_invsubBytes(uint8 *buf)
{
    int i;

	i = 16;		
	while (i--) {
		buf[i] = isbox[buf[i]];
	}
}

void aes_addRoundKey(uint8 *buf, uint8 *key)
{
    int i;

    i = 16;
    while (i--) {
		buf[i] ^= key[i];
    }
}

void aes_shiftRows(uint8 *buf)
{
    uint8 i, j;

    i = buf[1]; buf[1] = buf[5]; buf[5] = buf[9]; buf[9] = buf[13]; buf[13] = i;
    i = buf[10]; buf[10] = buf[2]; buf[2] = i;
    j = buf[14]; buf[14] = buf[6]; buf[6]  = j;
    j = buf[3]; buf[3] = buf[15]; buf[15] = buf[11]; buf[11] = buf[7]; buf[7] = j;
}

void aes_invshiftRows(uint8 *buf)
{
    uint8 i, j;

    i = buf[13]; buf[13] = buf[9]; buf[9] = buf[5]; buf[5] = buf[1]; buf[1] = i;
    i = buf[10]; buf[10] = buf[2]; buf[2] = i;
    j = buf[14]; buf[14] = buf[6]; buf[6]  = j;
    j = buf[3]; buf[3] = buf[7]; buf[7] = buf[11]; buf[11] = buf[15]; buf[15] = j;
}

void aes_mixColumns(uint8 *buf)
{
    uint8 a, b, c, d, e;
	int i;
	
    for (i = 0; i < 16; i += 4) {
        a = buf[i];
        b = buf[i + 1];
        c = buf[i + 2];
        d = buf[i + 3];
        
        e = a ^ b ^ c ^ d;

        buf[i] ^= (e ^ xtime(a^b));
        buf[i+1] ^= (e ^ xtime(b^c));
        buf[i+2] ^= (e ^ xtime(c^d));
        buf[i+3] ^= (e ^ xtime(d^a));
    }
}

void aes_invmixColumns(uint8 *buf)
{
    uint8 a, b, c, d, tmp[4];
    int i, j;
	
    for (i = 0; i < 16; i += 4) {
		for (j=0; j<4; j++) {
			a = buf[i+j];
			b = xtime(a);
			c = xtime(b);
			d = xtime(c);
        
			if (j==0) {
				tmp[0]  =     b ^ c ^ d;
				tmp[1]  = a ^         d;
				tmp[2]  = a ^     c ^ d;
				tmp[3]  = a ^ b ^     d;
			} else if (j==1) {
				tmp[0] ^= a ^ b ^     d;
				tmp[1] ^=     b ^ c ^ d;
				tmp[2] ^= a ^         d;
				tmp[3] ^= a ^     c ^ d;
			} else if (j==2) {
				tmp[0] ^= a ^     c ^ d;
				tmp[1] ^= a ^ b ^     d;
				tmp[2] ^=     b ^ c ^ d;
				tmp[3] ^= a ^         d;
			} else {
				tmp[0] ^= a ^         d;
				tmp[1] ^= a ^     c ^ d;
				tmp[2] ^= a ^ b ^     d;
				tmp[3] ^=     b ^ c ^ d;
			}
		}
		for (j=0; j<4; j++) {
			buf[i+j] = tmp[j];
		}
    }
}

/*********************************************************************
*                AES-ECB block encryption 
*            Input buffer same as output buffer
**********************************************************************/
void aes_encrypt_ecb(uint8 *inbuf, uint8 *outbuf, int keysize)
{
    int i;
    uint8 lps;

    if(keysize==256) {
		lps = 14;
    } else if (keysize==192) {
		lps = 12;
    } else {
		lps = 10;
    }

	mymemcpy(outbuf, inbuf, 16);
    
    aes_addRoundKey(outbuf, (uint8 *)&key_table[0]);

    for(i = 1; i < lps; i++) {
        aes_subBytes(outbuf);
        aes_shiftRows(outbuf); 
        aes_mixColumns(outbuf);
 		aes_addRoundKey(outbuf, (uint8 *)&key_table[i<<4]);
    }
    aes_subBytes(outbuf);
    aes_shiftRows(outbuf);
    aes_addRoundKey(outbuf, (uint8 *)&key_table[i<<4]);
}

/*********************************************************************
*                AES-ECB block decryption 
*            Input buffer same as output buffer
**********************************************************************/
void aes_decrypt_ecb(uint8 *inbuf, uint8 *outbuf, int keysize)
{
	int i;
	uint8 lps;
    
	// start doing the data stuff
	if (keysize==192) {
		lps = 12;
	} else if (keysize==256) {
		lps = 14;
	} else {
		lps = 10;
	}

	mymemcpy(outbuf, inbuf, 16);

	for (i=lps; i>0; i=i-1) {
		// XOR Roundkey
		aes_addRoundKey(outbuf, (uint8 *)&key_table[i<<4]);

		if (i!=lps) {
			 aes_invmixColumns(outbuf);
		}

		aes_invshiftRows(outbuf);
		aes_invsubBytes(outbuf);
	}
	aes_addRoundKey(outbuf, (uint8 *)&key_table[i<<4]);
}

